rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------------------------------------------------
    // Helpers (used only for WRITE rules to avoid get() on read paths)
    // -------------------------------------------------------------------------
    function userRole(data) {
      return data.get('role', 'user');
    }
    function isSuperadmin() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.get('role', 'user') == 'superadmin';
    }
    function isBarberOrSuperadmin() {
      let role = get(/databases/$(database)/documents/users/$(request.auth.uid)).data.get('role', 'user');
      return role == 'barber' || role == 'superadmin';
    }
    function barberBrandId() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.get('brand_id', '');
    }
    /// Barber document id for current user (set on users/{uid} when role is barber). Same doc as above — cached per request.
    function userBarberId() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.get('barber_id', '');
    }

    // -------------------------------------------------------------------------
    // Private: users — strict userId matching.
    // -------------------------------------------------------------------------
    match /users/{userId} {
      allow read: if request.auth != null && (request.auth.uid == userId || isBarberOrSuperadmin());
      
      // CREATE: Authenticated user can create their own doc.
      // MUST NOT set 'role' (default 'user' or missing).
      allow create: if request.auth != null
        && request.auth.uid == userId
        && (!('role' in request.resource.data) || request.resource.data.role == 'user');

      // UPDATE: Authenticated user can update own doc, BUT strict field control.
      // User CANNOT update: role, brand_id, barber_id, preferred_barber_id, lifetime_value.
      // Superadmin/Barber can update 'role' (conceptually, via Admin SDK usually, but if client-side, limit it).
      // For safety: User can ONLY update: fullName, phone, fcmToken, nextVisitDue, lastBookingDate.
      allow update: if request.auth != null
        && (
          (request.auth.uid == userId 
           && request.resource.data.role == resource.data.role
           && request.resource.data.lifetime_value == resource.data.lifetime_value)
          || isBarberOrSuperadmin()
        );
      
      allow delete: if false;

      // -----------------------------------------------------------------------
      // Subcollection: user_brands — user's joined brands with loyalty points
      // -----------------------------------------------------------------------
      match /user_brands/{brandId} {
        allow read: if request.auth != null && request.auth.uid == userId;
        
        // CREATE: User joining a brand. Initial points MUST be 0.
        allow create: if request.auth != null 
          && request.auth.uid == userId
          && request.resource.data.brand_id == brandId
          && request.resource.data.loyalty_points == 0;
          
        // UPDATE: User cannot update points. Only staff of THAT brand can update points.
        allow update: if request.auth != null 
          && (
             // User can update non-sensitive fields? (none currently defined)
             // Staff of THIS brand can update (add points)
             (isBarberOrSuperadmin() && barberBrandId() == brandId)
          );
          
        allow delete: if false;
      }
    }

    // -------------------------------------------------------------------------
    // Public: brands — authenticated read; write superadmin only (get on write).
    // -------------------------------------------------------------------------
    // -------------------------------------------------------------------------
    // Public: brands — authenticated read; write superadmin or owner (create allowed for onboarding).
    // -------------------------------------------------------------------------
    // -------------------------------------------------------------------------
    // Public: brands — authenticated read; write superadmin or owner (create allowed for onboarding).
    // -------------------------------------------------------------------------
    match /brands/{brandId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null;
      // Update: Superadmin can only update their OWN brand (must match user.brand_id)
      allow update, delete: if request.auth != null && isSuperadmin() && brandId == barberBrandId();
    }

    // -------------------------------------------------------------------------
    // Public: locations — authenticated read; write superadmin only.
    // -------------------------------------------------------------------------
    match /locations/{locationId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && isSuperadmin() && request.resource.data.brand_id == barberBrandId();
      allow update, delete: if request.auth != null && isSuperadmin() && resource.data.brand_id == barberBrandId();

      // -----------------------------------------------------------------------
      // Subcollections: daily_stats, monthly_stats — PROTECTED (Superadmin only)
      // -----------------------------------------------------------------------
      match /daily_stats/{dateId} {
        // Only superadmin of the parent location's brand can read stats.
        // We verify parent location's brand_id.
        allow read: if request.auth != null && isSuperadmin() 
          && get(/databases/$(database)/documents/locations/$(locationId)).data.brand_id == barberBrandId();
        allow list: if request.auth != null && isSuperadmin() 
          && get(/databases/$(database)/documents/locations/$(locationId)).data.brand_id == barberBrandId();
        allow write: if false; // Stats generated by Cloud Functions
      }

      match /monthly_stats/{monthId} {
        allow read: if request.auth != null && isSuperadmin() 
          && get(/databases/$(database)/documents/locations/$(locationId)).data.brand_id == barberBrandId();
        allow list: if request.auth != null && isSuperadmin() 
          && get(/databases/$(database)/documents/locations/$(locationId)).data.brand_id == barberBrandId();
        allow write: if false; // Stats generated by Cloud Functions
      }
    }

    // -------------------------------------------------------------------------
    // Public: barbers — authenticated read; write superadmin only.
    // -------------------------------------------------------------------------
    match /barbers/{document=**} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && isSuperadmin() && request.resource.data.brand_id == barberBrandId();
      allow update, delete: if request.auth != null && isSuperadmin() && resource.data.brand_id == barberBrandId();
    }

    // -------------------------------------------------------------------------
    // Public: services — authenticated read; write superadmin only.
    // -------------------------------------------------------------------------
    match /services/{document=**} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && isSuperadmin() && request.resource.data.brand_id == barberBrandId();
      allow update, delete: if request.auth != null && isSuperadmin() && resource.data.brand_id == barberBrandId();
    }

    // -------------------------------------------------------------------------
    // Public: availability — authenticated read; write for booking (no role get on read).
    // -------------------------------------------------------------------------
    match /availability/{document=**} {
      allow read: if request.auth != null;
      allow create, update: if request.auth != null;
      allow delete: if false;
    }

    // -------------------------------------------------------------------------
    // Public: rewards — authenticated read; write superadmin only.
    // -------------------------------------------------------------------------
    match /rewards/{rewardId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && isSuperadmin() && request.resource.data.brand_id == barberBrandId();
      allow update, delete: if request.auth != null && isSuperadmin() && resource.data.brand_id == barberBrandId();
    }

    // -------------------------------------------------------------------------
    // Private: appointments — owner OR staff of THAT brand.
    // -------------------------------------------------------------------------
    match /appointments/{appointmentId} {
      allow read: if request.auth != null
        && (resource.data.user_id == request.auth.uid
            || (isBarberOrSuperadmin() && resource.data.brand_id == barberBrandId())
            || (isBarberOrSuperadmin() && resource.data.barber_id == userBarberId())
           );
      allow create: if request.auth != null && request.resource.data.user_id == request.auth.uid;
      allow update: if request.auth != null
        && (resource.data.user_id == request.auth.uid 
            || (isBarberOrSuperadmin() && resource.data.brand_id == barberBrandId())
            || (isBarberOrSuperadmin() && resource.data.barber_id == userBarberId())
           );
      allow delete: if false;
    }

    // -------------------------------------------------------------------------
    // Private: user_booking_locks — composite key {userId}_{brandId}. No get() on read.
    // -------------------------------------------------------------------------
    match /user_booking_locks/{lockId} {
      // lockId format: {userId}_{brandId}
      function getUserIdFromLock() {
        return lockId.split('_')[0];
      }
      
      allow read: if request.auth != null 
        && (getUserIdFromLock() == request.auth.uid || isBarberOrSuperadmin());
      allow create, update: if request.auth != null 
        && (getUserIdFromLock() == request.auth.uid || isBarberOrSuperadmin());
      allow delete: if false;
    }

    // -------------------------------------------------------------------------
    // Private: reward_redemptions — user sees own; staff of THAT brand sees theirs.
    // -------------------------------------------------------------------------
    match /reward_redemptions/{redemptionId} {
      allow read: if request.auth != null && (
          resource == null
          || resource.data.user_id == request.auth.uid 
          || (isBarberOrSuperadmin() && resource.data.brand_id == barberBrandId())
      );
      allow create: if request.auth != null && request.resource.data.user_id == request.auth.uid;
      allow update: if request.auth != null
        && isBarberOrSuperadmin()
        && resource.data.brand_id == barberBrandId()
        && resource.data.status == 'pending';
      allow delete: if false;
    }

    // -------------------------------------------------------------------------
    // Public: time_off — authenticated read (needed for booking availability); write restricted.
    // -------------------------------------------------------------------------
    match /time_off/{timeOffId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null
        && isBarberOrSuperadmin()
        && request.resource.data.barber_id == userBarberId();
      allow update, delete: if request.auth != null
        && (
           resource.data.barber_id == userBarberId() 
           || (isSuperadmin() && resource.data.brand_id == barberBrandId())
        );
    }

    // Deny all other collections by default.
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
