rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------------------------------------------------
    // Helpers (used only for WRITE rules to avoid get() on read paths)
    // -------------------------------------------------------------------------
    function isSuperadmin() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.get('role', 'user') == 'superadmin';
    }
    function isBarberOrSuperadmin() {
      let role = get(/databases/$(database)/documents/users/$(request.auth.uid)).data.get('role', 'user');
      return role == 'barber' || role == 'superadmin';
    }
    function barberBrandId() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.get('brand_id', '');
    }
    /// Barber document id for current user (set on users/{uid} when role is barber). Same doc as above — cached per request.
    function userBarberId() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.get('barber_id', '');
    }

    // -------------------------------------------------------------------------
    // Private: users — strict userId matching.
    // -------------------------------------------------------------------------
    match /users/{userId} {
      allow read: if request.auth != null && (request.auth.uid == userId || isBarberOrSuperadmin());
      
      // CREATE: Authenticated user can create their own doc.
      // Can set role to 'user' or 'superadmin' (superadmin determined by email whitelist in code).
      // Other roles (barber) must be set server-side.
      allow create: if request.auth != null
        && request.auth.uid == userId
        && (!('role' in request.resource.data) 
            || request.resource.data.role == 'user' 
            || request.resource.data.role == 'superadmin');

      // UPDATE: Authenticated user can update own doc, BUT strict field control.
      // Server-managed fields (Cloud Functions only): lifetime_value, last_booking_date, 
      //   next_visit_due, average_visit_interval, reminded_this_cycle
      // Staff-managed fields: brand_id, barber_id, preferred_barber_id
      // User CAN: Update fullName, phone, fcmToken
      // User CAN: Upgrade role from 'user' to 'superadmin' (email whitelist in code)
      // Superadmin/Barber: Can update any field
      allow update: if request.auth != null
        && (
          (request.auth.uid == userId 
           // Role: Allow same role, or upgrade user->superadmin
           && (!('role' in request.resource.data) 
               || request.resource.data.role == resource.data.get('role', 'user')
               || (resource.data.get('role', 'user') == 'user' && request.resource.data.role == 'superadmin'))
           // Server-managed fields: Client must NEVER write these
           && !('lifetime_value' in request.resource.data)
           && !('last_booking_date' in request.resource.data)
           && !('next_visit_due' in request.resource.data)
           && !('average_visit_interval' in request.resource.data)
           && !('reminded_this_cycle' in request.resource.data)
           // Staff-managed fields: Client can write empty string (for new users), but not change existing
           && (!('brand_id' in request.resource.data) || request.resource.data.brand_id == resource.data.get('brand_id', ''))
           && (!('barber_id' in request.resource.data) || request.resource.data.barber_id == resource.data.get('barber_id', ''))
           && (!('preferred_barber_id' in request.resource.data) || request.resource.data.preferred_barber_id == resource.data.get('preferred_barber_id', '')))
          || isBarberOrSuperadmin()
        );
      
      allow delete: if false;

      // -----------------------------------------------------------------------
      // Subcollection: user_brands — user's joined brands with loyalty points
      // -----------------------------------------------------------------------
      match /user_brands/{brandId} {
        allow read: if request.auth != null && request.auth.uid == userId;
        
        // CREATE: User joining a brand. Initial points MUST be 0.
        allow create: if request.auth != null 
          && request.auth.uid == userId
          && request.resource.data.brand_id == brandId
          && request.resource.data.loyalty_points == 0;
          
        // UPDATE: User cannot update points. Only staff of THAT brand can update points.
        allow update: if request.auth != null 
          && (
             // User can update non-sensitive fields? (none currently defined)
             // Staff of THIS brand can update (add points)
             (isBarberOrSuperadmin() && barberBrandId() == brandId)
          );
          
        allow delete: if false;
      }
    }

    // -------------------------------------------------------------------------
    // Public: brands — authenticated read; write superadmin only (get on write).
    // -------------------------------------------------------------------------
    // -------------------------------------------------------------------------
    // Public: brands — authenticated read; write superadmin or owner (create allowed for onboarding).
    // -------------------------------------------------------------------------
    // -------------------------------------------------------------------------
    // Public: brands — authenticated read; write superadmin or owner (create allowed for onboarding).
    // -------------------------------------------------------------------------
    match /brands/{brandId} {
      allow read: if true;
      allow create: if request.auth != null;
      // Update: Superadmin can only update their OWN brand (must match user.brand_id)
      allow update, delete: if request.auth != null && isSuperadmin() && brandId == barberBrandId();
    }

    // -------------------------------------------------------------------------
    // Public: locations — read for everyone (guest booking flow); write superadmin only.
    // -------------------------------------------------------------------------
    match /locations/{locationId} {
      allow read: if true;
      allow create: if request.auth != null && isSuperadmin() && request.resource.data.brand_id == barberBrandId();
      allow update, delete: if request.auth != null && isSuperadmin() && resource.data.brand_id == barberBrandId();

      // -----------------------------------------------------------------------
      // Subcollections: daily_stats, monthly_stats — PROTECTED (Superadmin only)
      // -----------------------------------------------------------------------
      match /daily_stats/{dateId} {
        // Only superadmin of the parent location's brand can read stats.
        // We verify parent location's brand_id.
        allow read: if request.auth != null && isSuperadmin() 
          && get(/databases/$(database)/documents/locations/$(locationId)).data.brand_id == barberBrandId();
        allow list: if request.auth != null && isSuperadmin() 
          && get(/databases/$(database)/documents/locations/$(locationId)).data.brand_id == barberBrandId();
        allow write: if false; // Stats generated by Cloud Functions
      }

      match /monthly_stats/{monthId} {
        allow read: if request.auth != null && isSuperadmin() 
          && get(/databases/$(database)/documents/locations/$(locationId)).data.brand_id == barberBrandId();
        allow list: if request.auth != null && isSuperadmin() 
          && get(/databases/$(database)/documents/locations/$(locationId)).data.brand_id == barberBrandId();
        allow write: if false; // Stats generated by Cloud Functions
      }
    }

    // -------------------------------------------------------------------------
    // Public: barbers — read for everyone (guest booking flow); write superadmin only.
    // -------------------------------------------------------------------------
    match /barbers/{document=**} {
      allow read: if true;
      allow create: if request.auth != null && isSuperadmin() && request.resource.data.brand_id == barberBrandId();
      allow update, delete: if request.auth != null && isSuperadmin() && resource.data.brand_id == barberBrandId();
    }

    // -------------------------------------------------------------------------
    // Public: services — read for everyone (guest booking flow); write superadmin only.
    // -------------------------------------------------------------------------
    match /services/{document=**} {
      allow read: if true;
      allow create: if request.auth != null && isSuperadmin() && request.resource.data.brand_id == barberBrandId();
      allow update, delete: if request.auth != null && isSuperadmin() && resource.data.brand_id == barberBrandId();
    }

    // -------------------------------------------------------------------------
    // Public: availability — read for everyone (guest booking flow); write for booking.
    // -------------------------------------------------------------------------
    match /availability/{document=**} {
      allow read: if true;
      allow create, update: if request.auth != null;
      allow delete: if false;
    }

    // -------------------------------------------------------------------------
    // Public: rewards — authenticated read; write superadmin only.
    // -------------------------------------------------------------------------
    match /rewards/{rewardId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && isSuperadmin() && request.resource.data.brand_id == barberBrandId();
      allow update, delete: if request.auth != null && isSuperadmin() && resource.data.brand_id == barberBrandId();
    }

    // -------------------------------------------------------------------------
    // Private: appointments — owner OR staff of THAT brand.
    // -------------------------------------------------------------------------
    match /appointments/{appointmentId} {
      allow read: if request.auth != null
        && (resource.data.user_id == request.auth.uid
            || (isBarberOrSuperadmin() && resource.data.brand_id == barberBrandId())
            || (isBarberOrSuperadmin() && resource.data.barber_id == userBarberId())
           );
      allow create: if request.auth != null && request.resource.data.user_id == request.auth.uid;
      allow update: if request.auth != null
        && (resource.data.user_id == request.auth.uid 
            || (isBarberOrSuperadmin() && resource.data.brand_id == barberBrandId())
            || (isBarberOrSuperadmin() && resource.data.barber_id == userBarberId())
           );
      allow delete: if false;
    }

    // -------------------------------------------------------------------------
    // Private: user_booking_locks — composite key {userId}_{brandId}. No get() on read.
    // -------------------------------------------------------------------------
    match /user_booking_locks/{lockId} {
      // lockId format: {userId}_{brandId}
      function getUserIdFromLock() {
        return lockId.split('_')[0];
      }
      
      allow read: if request.auth != null 
        && (getUserIdFromLock() == request.auth.uid || isBarberOrSuperadmin());
      allow create, update: if request.auth != null 
        && (getUserIdFromLock() == request.auth.uid || isBarberOrSuperadmin());
      allow delete: if false;
    }

    // -------------------------------------------------------------------------
    // Private: reward_redemptions — user sees own; staff of THAT brand sees theirs.
    // -------------------------------------------------------------------------
    match /reward_redemptions/{redemptionId} {
      allow read: if request.auth != null && (
          resource == null
          || resource.data.user_id == request.auth.uid 
          || (isBarberOrSuperadmin() && resource.data.brand_id == barberBrandId())
      );
      allow create: if request.auth != null && request.resource.data.user_id == request.auth.uid;
      allow update: if request.auth != null
        && isBarberOrSuperadmin()
        && resource.data.brand_id == barberBrandId()
        && resource.data.status == 'pending';
      allow delete: if false;
    }

    // -------------------------------------------------------------------------
    // Public: time_off — read for everyone (guest booking availability); write restricted.
    // -------------------------------------------------------------------------
    match /time_off/{timeOffId} {
      allow read: if true;
      allow create: if request.auth != null
        && isBarberOrSuperadmin()
        && request.resource.data.barber_id == userBarberId();
      allow update, delete: if request.auth != null
        && (
           resource.data.barber_id == userBarberId() 
           || (isSuperadmin() && resource.data.brand_id == barberBrandId())
        );
    }

    // Deny all other collections by default.
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
